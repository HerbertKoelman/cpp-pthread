\hypertarget{classpthread_1_1condition__variable}{}\section{pthread\+:\+:condition\+\_\+variable Class Reference}
\label{classpthread_1_1condition__variable}\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}


{\ttfamily \#include $<$condition\+\_\+variable.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{wait} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx)
\item 
void \hyperlink{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}{wait} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ lck)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}{wait} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, Lambda lambda)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}{wait} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, Lambda lambda)
\item 
\hyperlink{group__concurrency_ga823f88a2bf448bd5bd5273b826830bdd}{cv\+\_\+status} \hyperlink{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, int millis)
\item 
\hyperlink{group__concurrency_ga823f88a2bf448bd5bd5273b826830bdd}{cv\+\_\+status} \hyperlink{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}{wait\+\_\+for} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, int millis)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, int millis, Lambda lambda)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}{wait\+\_\+for} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, int millis, Lambda lambda)
\item 
void \hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} () noexcept
\item 
void \hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} () noexcept
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Condition variable.

The \hyperlink{classpthread_1_1condition__variable}{condition\+\_\+variable} class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the condition), and notifies the \hyperlink{classpthread_1_1condition__variable}{condition\+\_\+variable}.

The thread that intends to modify the variable has to
\begin{DoxyItemize}
\item acquire a \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} (typically via \hyperlink{classpthread_1_1lock__guard}{pthread\+::lock\+\_\+guard})
\item perform the modification while the lock is held
\item execute notify\+\_\+one or notify\+\_\+all on the \hyperlink{classpthread_1_1condition__variable}{pthread\+::condition\+\_\+variable} (the lock does not need to be held for notification)
\end{DoxyItemize}

Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.

Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.

\begin{DoxyAuthor}{Author}
herbert koelman (\href{mailto:herbert.koelman@me.com}{\tt herbert.\+koelman@me.\+com}) 
\end{DoxyAuthor}


Definition at line 56 of file condition\+\_\+variable.\+hpp.



\subsection{Member Function Documentation}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!notify\+\_\+all@{notify\+\_\+all}}
\index{notify\+\_\+all@{notify\+\_\+all}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{notify\+\_\+all() noexcept}{notify\_all() noexcept}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::notify\+\_\+all (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\hypertarget{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{}\label{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}
Signal all waiting threads.

The call unblocks all threads currently blocked on the specified condition variable cond. 

Definition at line 61 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!notify\+\_\+one@{notify\+\_\+one}}
\index{notify\+\_\+one@{notify\+\_\+one}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{notify\+\_\+one() noexcept}{notify\_one() noexcept}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::notify\+\_\+one (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\hypertarget{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{}\label{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}
Signal one waiting thread.

The call unblocks at least one of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond). 

Definition at line 53 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(mutex \&mtx)}{wait(mutex \&mtx)}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{}\label{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}
Wait for condition to be signaled.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 5 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(lock\+\_\+guard$<$ pthread\+::mutex $>$ lck)}{wait(lock\_guard< pthread::mutex > lck)}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$}]{lck}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}{}\label{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{wait} 
\end{DoxySeeAlso}


Definition at line 9 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(mutex \&mtx, Lambda lambda)}{wait(mutex \&mtx, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}{}\label{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}
Wait for condition to be signaled.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should return false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool pred();


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 209 of file condition\+\_\+variable.\+hpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, Lambda lambda)}{wait(lock\_guard< pthread::mutex > \&lck, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}{}\label{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}
Wait for condition to be signaled.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should return false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool pred();


\begin{DoxyParams}{Parameters}
{\em lck} & ralated mutex \hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}, which must be locked by the current thread. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 221 of file condition\+\_\+variable.\+hpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(mutex \&mtx, int millis)}{wait\_for(mutex \&mtx, int millis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cv\+\_\+status} pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{int}]{millis}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{}\label{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}
Wait for condition to be signaled within given time frame.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

If this method is called with millis $<$ 0 then the timeout time is not recalculated. This make it possible to handle spurious unblocking of condition variable without the need of a lambda expression. The call sequence is then\+: while(! check\+\_\+condition() \&\& wait\+\_\+for(lck, 200) == no\+\_\+tiemout );


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em millis} & milliseconds to wait for this instance to signaled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cv\+\_\+status (either timeout or no\+\_\+timeout) 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classpthread_1_1condition__variable__exception}{condition\+\_\+variable\+\_\+exception}} & is thrown either if timeout calculation failed or mutex ownership was wrong. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 20 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, int millis)}{wait\_for(lock\_guard< pthread::mutex > \&lck, int millis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cv\+\_\+status} pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{int}]{millis}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}{}\label{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&, int) 
\end{DoxySeeAlso}


Definition at line 14 of file condition\+\_\+variable.\+cpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(mutex \&mtx, int millis, Lambda lambda)}{wait\_for(mutex \&mtx, int millis, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{int}]{millis, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}{}\label{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}
Wait for condition to be signaled within a given time frame.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should return false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool lambda();


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em millis} & milli seconds to wait for condition to be signaled. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 227 of file condition\+\_\+variable.\+hpp.

\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, int millis, Lambda lambda)}{wait\_for(lock\_guard< pthread::mutex > \&lck, int millis, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{int}]{millis, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}{}\label{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}
Wait for condition to be signaled within a given time frame.

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should return false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool lambda();


\begin{DoxyParams}{Parameters}
{\em lck} & ralated mutex \hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}, which must be locked by the current thread. \\
\hline
{\em millis} & milli seconds to wait for condition to be signaled. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_ae374b1e852f36fc5eac93ad90d9fc85a}{notify\+\_\+one} 

\hyperlink{classpthread_1_1condition__variable_ae40f0c9043ed693317bb9a07861efc65}{notify\+\_\+all} 
\end{DoxySeeAlso}


Definition at line 263 of file condition\+\_\+variable.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/pthread/condition\+\_\+variable.\+hpp\item 
src/condition\+\_\+variable.\+cpp\end{DoxyCompactItemize}
