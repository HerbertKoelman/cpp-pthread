\hypertarget{classpthread_1_1condition__variable}{}\section{pthread\+:\+:condition\+\_\+variable Class Reference}
\label{classpthread_1_1condition__variable}\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}


{\ttfamily \#include $<$condition\+\_\+variable.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{wait} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx)
\item 
void \hyperlink{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}{wait} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ lck)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}{wait} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, Lambda lambda)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}{wait} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, Lambda lambda)
\item 
\hyperlink{namespacepthread_a823f88a2bf448bd5bd5273b826830bdd}{cv\+\_\+status} \hyperlink{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, int millis)
\item 
\hyperlink{namespacepthread_a823f88a2bf448bd5bd5273b826830bdd}{cv\+\_\+status} \hyperlink{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}{wait\+\_\+for} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, int millis)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&mtx, int millis, Lambda lambda)
\item 
{\footnotesize template$<$class Lambda $>$ }\\bool \hyperlink{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}{wait\+\_\+for} (\hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}$<$ \hyperlink{classpthread_1_1mutex}{pthread\+::mutex} $>$ \&lck, int millis, Lambda lambda)
\item 
void \hyperlink{classpthread_1_1condition__variable_a71a7f70ef29da791b1525d1ab8af01ea}{notify\+\_\+one} ()  throw ()
\item 
void \hyperlink{classpthread_1_1condition__variable_a8aed3a66334aec0e3a82090ac4d05483}{notify\+\_\+all} ()  throw ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
pthread condition variable

The \hyperlink{classpthread_1_1condition__variable}{condition\+\_\+variable} class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the condition), and notifies the \hyperlink{classpthread_1_1condition__variable}{condition\+\_\+variable}.

The thread that intends to modify the variable has to
\begin{DoxyItemize}
\item acquire a std\+::mutex (typically via std\+::lock\+\_\+guard)
\item perform the modification while the lock is held
\item execute notify\+\_\+one or notify\+\_\+all on the std\+::condition\+\_\+variable (the lock does not need to be held for notification)
\end{DoxyItemize}

Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.

Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.

\begin{DoxyAuthor}{Author}
herbert koelman 
\end{DoxyAuthor}


\subsection{Member Function Documentation}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!notify\+\_\+all@{notify\+\_\+all}}
\index{notify\+\_\+all@{notify\+\_\+all}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{notify\+\_\+all()}{notify_all()}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::notify\+\_\+all (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) throw  ) }\hypertarget{classpthread_1_1condition__variable_a8aed3a66334aec0e3a82090ac4d05483}{}\label{classpthread_1_1condition__variable_a8aed3a66334aec0e3a82090ac4d05483}
signal all waiting threads The pthread\+\_\+cond\+\_\+broadcast() call unblocks all threads currently blocked on the specified condition variable cond. \index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!notify\+\_\+one@{notify\+\_\+one}}
\index{notify\+\_\+one@{notify\+\_\+one}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{notify\+\_\+one()}{notify_one()}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::notify\+\_\+one (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) throw  ) }\hypertarget{classpthread_1_1condition__variable_a71a7f70ef29da791b1525d1ab8af01ea}{}\label{classpthread_1_1condition__variable_a71a7f70ef29da791b1525d1ab8af01ea}
signal one waiting thread.

The pthread\+\_\+cond\+\_\+signal() call unblocks at least one of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond). \index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(mutex \&mtx)}{wait(mutex &mtx)}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{}\label{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}
wait for condition to be signaled

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
\end{DoxyParams}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(lock\+\_\+guard$<$ pthread\+::mutex $>$ lck)}{wait(lock_guard< pthread::mutex > lck)}}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$}]{lck}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}{}\label{classpthread_1_1condition__variable_a9bb3e49f17ec1470c305d8b21daadf2a}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_a34247dacb9da1856f3a65bc868b6abb8}{wait} 
\end{DoxySeeAlso}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(mutex \&mtx, Lambda lambda)}{wait(mutex &mtx, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}{}\label{classpthread_1_1condition__variable_a251a506415355171be3052b68bc8d2ec}
wait for condition to be signaled

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool pred();


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait@{wait}}
\index{wait@{wait}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, Lambda lambda)}{wait(lock_guard< pthread::mutex > &lck, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}{}\label{classpthread_1_1condition__variable_a7b6c075d1588178301547bc60c59ceba}
wait for condition to be signaled

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool pred();


\begin{DoxyParams}{Parameters}
{\em lck} & ralated mutex \hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}, which must be locked by the current thread. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(mutex \&mtx, int millis)}{wait_for(mutex &mtx, int millis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cv\+\_\+status} pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{int}]{millis}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{}\label{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}
wait for condition to be signaled within given time frame

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

If this method is called with millis $<$ 0 then the timeout time is not recalculated. This make it possible to handle spurious unblocking of condition variable without the need of a lambda expression. The call sequence is then\+: while(! check\+\_\+condition() \&\& wait\+\_\+for(lck, 200) == no\+\_\+tiemout );


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em millis} & milliseconds to wait for this instance to signaled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cv\+\_\+status (either timeout or no\+\_\+timeout) 
\end{DoxyReturn}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, int millis)}{wait_for(lock_guard< pthread::mutex > &lck, int millis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cv\+\_\+status} pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{int}]{millis}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}{}\label{classpthread_1_1condition__variable_a1dfcedf00e9822587c7b20da9c060fd9}
\begin{DoxySeeAlso}{See also}
\hyperlink{classpthread_1_1condition__variable_a804a305eefb4da8abecd1e6326b82785}{wait\+\_\+for} (\hyperlink{classpthread_1_1mutex}{mutex} \&, int) 
\end{DoxySeeAlso}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(mutex \&mtx, int millis, Lambda lambda)}{wait_for(mutex &mtx, int millis, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf mutex} \&}]{mtx, }
\item[{int}]{millis, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}{}\label{classpthread_1_1condition__variable_a82fb3ff516ffef37c68f58e277fad855}
wait for condition to be signaled within a given time frame

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool lambda();


\begin{DoxyParams}{Parameters}
{\em mtx} & ralated mutex, which must be locked by the current thread. \\
\hline
{\em millis} & milli seconds to wait for condition to be signaled. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}
\index{pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}!wait\+\_\+for@{wait\+\_\+for}}
\index{wait\+\_\+for@{wait\+\_\+for}!pthread\+::condition\+\_\+variable@{pthread\+::condition\+\_\+variable}}
\subsubsection[{\texorpdfstring{wait\+\_\+for(lock\+\_\+guard$<$ pthread\+::mutex $>$ \&lck, int millis, Lambda lambda)}{wait_for(lock_guard< pthread::mutex > &lck, int millis, Lambda lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Lambda $>$ bool pthread\+::condition\+\_\+variable\+::wait\+\_\+for (
\begin{DoxyParamCaption}
\item[{{\bf lock\+\_\+guard}$<$ {\bf pthread\+::mutex} $>$ \&}]{lck, }
\item[{int}]{millis, }
\item[{Lambda}]{lambda}
\end{DoxyParamCaption}
)}\hypertarget{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}{}\label{classpthread_1_1condition__variable_a5ee32edbf76592ec443e2544ecba811a}
wait for condition to be signaled within a given time frame

This method atomically release mutex and cause the calling thread to block; atomically here means \char`\"{}atomically with respect to
access by another thread to the mutex and then the condition variable\char`\"{}. Call notify\+\_\+one or notify\+\_\+all to signal the condition.

Upon successful return, the mutex has been locked and is owned by the calling thread.

The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following\+: bool lambda();


\begin{DoxyParams}{Parameters}
{\em lck} & ralated mutex \hyperlink{classpthread_1_1lock__guard}{lock\+\_\+guard}, which must be locked by the current thread. \\
\hline
{\em millis} & milli seconds to wait for condition to be signaled. \\
\hline
{\em lambda} & run to check if condition was met. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if lmabda returned true. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/pthread/condition\+\_\+variable.\+hpp\item 
src/condition\+\_\+variable.\+cpp\end{DoxyCompactItemize}
