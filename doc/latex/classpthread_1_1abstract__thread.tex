\hypertarget{classpthread_1_1abstract__thread}{\section{pthread\+:\+:abstract\+\_\+thread Class Reference}
\label{classpthread_1_1abstract__thread}\index{pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}}
}


{\ttfamily \#include $<$thread.\+hpp$>$}

Inheritance diagram for pthread\+:\+:abstract\+\_\+thread\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classpthread_1_1abstract__thread}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classpthread_1_1abstract__thread_aef9de5da73087b69d00f71985a4cbdef}{abstract\+\_\+thread} (const std\+::size\+\_\+t stack\+\_\+size=0)
\item 
void \hyperlink{classpthread_1_1abstract__thread_ab121718028f3ca68d45db84d10ff2a3a}{start} ()
\item 
int \hyperlink{classpthread_1_1abstract__thread_aedac81bb9eb76ba92c49c48d797ea25b}{join} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
base class of a thread.

utility class, that wraps a thread. 
\begin{DoxyPre}{\ttfamily 
class worker: public \hyperlink{classpthread_1_1abstract__thread}{pthread::abstract\_thread} \{
public:}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   worker(const std::string m = "anonymous worker", int sleep = 2*1000): msg(m), \_sleep(sleep)\{
  \};}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   ~worker()\{
  \};}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   void \hyperlink{classpthread_1_1runnable_a4e0ce933602df83c096a37974ebedf84}{run()} noexcept override \{
    \{ // critical section scope
      pthread::lock\_guard<pthread::mutex> lck(mtx);}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily       bool stop\_waiting = true; // if lambda syntax is not availbale then use this kind of implementation
      auto delay = \_sleep; // use sleep seconds to calculate point in time timeout
      while ( ! (stop\_waiting = (counter >= 10000)) \&\& (condition.wait\_for(mtx, delay) == pthread::cv\_status::no\_timeout))\{
        delay = -1 ; // if timeout millis is negatif, then we keep last timeout calculation.
      \}}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily       if ( counter >= 10000 ) \{
        message("worker class, counter >= 10000");
      \} else \{
        message("worker class, counter < 10000");
      \}
    \} // end of critical section}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily     pthread::this\_thread::sleep(200);
  \};}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily private:
  std::string    msg ;
  int            \_sleep;
\};}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily int main(int argc, const char * argv[]) \{}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   \hyperlink{classpthread_1_1thread__group}{pthread::thread\_group} threads(true); // indicate that we want to join referenced threads when deallocating this instance.
  for (auto x = 10 ; x > 0 ; x--)\{
    threads.add( new worker("herbert"));
  \}}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   threads.start(); // start running all threads}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   for ( auto x = 20000 ; x > 0 ; x--)\{
    pthread::lock\_guard<pthread::mutex> lck(mtx);
    counter++ ;
  \}}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily   condition.notify\_all();
\}}\end{DoxyPre}



\begin{DoxyPre}{\ttfamily }\end{DoxyPre}
 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classpthread_1_1abstract__thread_aef9de5da73087b69d00f71985a4cbdef}{\index{pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}!abstract\+\_\+thread@{abstract\+\_\+thread}}
\index{abstract\+\_\+thread@{abstract\+\_\+thread}!pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}}
\subsubsection[{abstract\+\_\+thread}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+::abstract\+\_\+thread\+::abstract\+\_\+thread (
\begin{DoxyParamCaption}
\item[{const std\+::size\+\_\+t}]{stack\+\_\+size = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{classpthread_1_1abstract__thread_aef9de5da73087b69d00f71985a4cbdef}
setup thread base.


\begin{DoxyParams}{Parameters}
{\em stack\+\_\+size} & thread's stack size (default 0 which means use P\+T\+H\+R\+E\+A\+D\+\_\+\+S\+T\+A\+C\+K\+\_\+\+M\+I\+N) \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classpthread_1_1abstract__thread_aedac81bb9eb76ba92c49c48d797ea25b}{\index{pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}!join@{join}}
\index{join@{join}!pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}}
\subsubsection[{join}]{\setlength{\rightskip}{0pt plus 5cm}int pthread\+::abstract\+\_\+thread\+::join (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classpthread_1_1abstract__thread_aedac81bb9eb76ba92c49c48d797ea25b}
joins this thread.


\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classpthread_1_1pthread__exception}{pthread\+\_\+exception}} & if deadlock conditions are detected. \\
\hline
\end{DoxyExceptions}
\hypertarget{classpthread_1_1abstract__thread_ab121718028f3ca68d45db84d10ff2a3a}{\index{pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}!start@{start}}
\index{start@{start}!pthread\+::abstract\+\_\+thread@{pthread\+::abstract\+\_\+thread}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}void pthread\+::abstract\+\_\+thread\+::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classpthread_1_1abstract__thread_ab121718028f3ca68d45db84d10ff2a3a}
start running the {\ttfamily \hyperlink{classpthread_1_1runnable_a4e0ce933602df83c096a37974ebedf84}{run()}} method in a new thread. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/pthread/thread.\+hpp\item 
src/thread.\+cpp\end{DoxyCompactItemize}
