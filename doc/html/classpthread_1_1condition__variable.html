<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C++ pThread wrapper: pthread::condition_variable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ pThread wrapper
   &#160;<span id="projectnumber">(v1.2.2)</span>
   </div>
   <div id="projectbrief">Simple C++ wrapper to pthread functions.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepthread.html">pthread</a></li><li class="navelem"><a class="el" href="classpthread_1_1condition__variable.html">condition_variable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpthread_1_1condition__variable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pthread::condition_variable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="condition__variable_8hpp_source.html">condition_variable.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34247dacb9da1856f3a65bc868b6abb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a34247dacb9da1856f3a65bc868b6abb8">wait</a> (<a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;mtx)</td></tr>
<tr class="separator:a34247dacb9da1856f3a65bc868b6abb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb3e49f17ec1470c305d8b21daadf2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a9bb3e49f17ec1470c305d8b21daadf2a">wait</a> (<a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; lck)</td></tr>
<tr class="separator:a9bb3e49f17ec1470c305d8b21daadf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a506415355171be3052b68bc8d2ec"><td class="memTemplParams" colspan="2">template&lt;class Lambda &gt; </td></tr>
<tr class="memitem:a251a506415355171be3052b68bc8d2ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a251a506415355171be3052b68bc8d2ec">wait</a> (<a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;mtx, Lambda lambda)</td></tr>
<tr class="separator:a251a506415355171be3052b68bc8d2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6c075d1588178301547bc60c59ceba"><td class="memTemplParams" colspan="2">template&lt;class Lambda &gt; </td></tr>
<tr class="memitem:a7b6c075d1588178301547bc60c59ceba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a7b6c075d1588178301547bc60c59ceba">wait</a> (<a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;lck, Lambda lambda)</td></tr>
<tr class="separator:a7b6c075d1588178301547bc60c59ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804a305eefb4da8abecd1e6326b82785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepthread.html#a823f88a2bf448bd5bd5273b826830bdd">cv_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a804a305eefb4da8abecd1e6326b82785">wait_for</a> (<a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;mtx, int millis)</td></tr>
<tr class="separator:a804a305eefb4da8abecd1e6326b82785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfcedf00e9822587c7b20da9c060fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepthread.html#a823f88a2bf448bd5bd5273b826830bdd">cv_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a1dfcedf00e9822587c7b20da9c060fd9">wait_for</a> (<a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;lck, int millis)</td></tr>
<tr class="separator:a1dfcedf00e9822587c7b20da9c060fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fb3ff516ffef37c68f58e277fad855"><td class="memTemplParams" colspan="2">template&lt;class Lambda &gt; </td></tr>
<tr class="memitem:a82fb3ff516ffef37c68f58e277fad855"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a82fb3ff516ffef37c68f58e277fad855">wait_for</a> (<a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;mtx, int millis, Lambda lambda)</td></tr>
<tr class="separator:a82fb3ff516ffef37c68f58e277fad855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee32edbf76592ec443e2544ecba811a"><td class="memTemplParams" colspan="2">template&lt;class Lambda &gt; </td></tr>
<tr class="memitem:a5ee32edbf76592ec443e2544ecba811a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a5ee32edbf76592ec443e2544ecba811a">wait_for</a> (<a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;lck, int millis, Lambda lambda)</td></tr>
<tr class="separator:a5ee32edbf76592ec443e2544ecba811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a7f70ef29da791b1525d1ab8af01ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a71a7f70ef29da791b1525d1ab8af01ea">notify_one</a> ()  throw ()</td></tr>
<tr class="separator:a71a7f70ef29da791b1525d1ab8af01ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aed3a66334aec0e3a82090ac4d05483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpthread_1_1condition__variable.html#a8aed3a66334aec0e3a82090ac4d05483">notify_all</a> ()  throw ()</td></tr>
<tr class="separator:a8aed3a66334aec0e3a82090ac4d05483"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>pthread condition variable</p>
<p>The <a class="el" href="classpthread_1_1condition__variable.html">condition_variable</a> class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the condition), and notifies the <a class="el" href="classpthread_1_1condition__variable.html">condition_variable</a>.</p>
<p>The thread that intends to modify the variable has to</p><ul>
<li>acquire a std::mutex (typically via std::lock_guard)</li>
<li>perform the modification while the lock is held</li>
<li>execute notify_one or notify_all on the std::condition_variable (the lock does not need to be held for notification)</li>
</ul>
<p>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</p>
<p>Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.</p>
<dl class="section author"><dt>Author</dt><dd>herbert koelman </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8aed3a66334aec0e3a82090ac4d05483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread::condition_variable::notify_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>signal all waiting threads The pthread_cond_broadcast() call unblocks all threads currently blocked on the specified condition variable cond. </p>

</div>
</div>
<a class="anchor" id="a71a7f70ef29da791b1525d1ab8af01ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread::condition_variable::notify_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>signal one waiting thread.</p>
<p>The pthread_cond_signal() call unblocks at least one of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond). </p>

</div>
</div>
<a class="anchor" id="a34247dacb9da1856f3a65bc868b6abb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>ralated mutex, which must be locked by the current thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bb3e49f17ec1470c305d8b21daadf2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt;&#160;</td>
          <td class="paramname"><em>lck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpthread_1_1condition__variable.html#a34247dacb9da1856f3a65bc868b6abb8">wait</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a251a506415355171be3052b68bc8d2ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pthread::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<p>The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following: bool pred();</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>ralated mutex, which must be locked by the current thread. </td></tr>
    <tr><td class="paramname">lambda</td><td>run to check if condition was met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lmabda returned true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b6c075d1588178301547bc60c59ceba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pthread::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<p>The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following: bool pred();</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>ralated mutex <a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>, which must be locked by the current thread. </td></tr>
    <tr><td class="paramname">lambda</td><td>run to check if condition was met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lmabda returned true. </dd></dl>

</div>
</div>
<a class="anchor" id="a804a305eefb4da8abecd1e6326b82785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepthread.html#a823f88a2bf448bd5bd5273b826830bdd">cv_status</a> pthread::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled within given time frame</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<p>If this method is called with millis &lt; 0 then the timeout time is not recalculated. This make it possible to handle spurious unblocking of condition variable without the need of a lambda expression. The call sequence is then: while(! check_condition() &amp;&amp; wait_for(lck, 200) == no_tiemout );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>ralated mutex, which must be locked by the current thread. </td></tr>
    <tr><td class="paramname">millis</td><td>milliseconds to wait for this instance to signaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cv_status (either timeout or no_timeout) </dd></dl>

</div>
</div>
<a class="anchor" id="a1dfcedf00e9822587c7b20da9c060fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepthread.html#a823f88a2bf448bd5bd5273b826830bdd">cv_status</a> pthread::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpthread_1_1condition__variable.html#a804a305eefb4da8abecd1e6326b82785">wait_for</a> (<a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;, int) </dd></dl>

</div>
</div>
<a class="anchor" id="a82fb3ff516ffef37c68f58e277fad855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pthread::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled within a given time frame</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<p>The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following: bool lambda();</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>ralated mutex, which must be locked by the current thread. </td></tr>
    <tr><td class="paramname">millis</td><td>milli seconds to wait for condition to be signaled. </td></tr>
    <tr><td class="paramname">lambda</td><td>run to check if condition was met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lmabda returned true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ee32edbf76592ec443e2544ecba811a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pthread::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>&lt; <a class="el" href="classpthread_1_1mutex.html">pthread::mutex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait for condition to be signaled within a given time frame</p>
<p>This method atomically release mutex and cause the calling thread to block; atomically here means "atomically with respect to
access by another thread to the mutex and then the condition variable". Call notify_one or notify_all to signal the condition.</p>
<p>Upon successful return, the mutex has been locked and is owned by the calling thread.</p>
<p>The lambda (closure) is run to check if the condition was met. Lambda should false if the waiting should be continued. The signature of the predicate function should be equivalent to the following: bool lambda();</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lck</td><td>ralated mutex <a class="el" href="classpthread_1_1lock__guard.html">lock_guard</a>, which must be locked by the current thread. </td></tr>
    <tr><td class="paramname">millis</td><td>milli seconds to wait for condition to be signaled. </td></tr>
    <tr><td class="paramname">lambda</td><td>run to check if condition was met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lmabda returned true. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pthread/<a class="el" href="condition__variable_8hpp_source.html">condition_variable.hpp</a></li>
<li>src/condition_variable.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
